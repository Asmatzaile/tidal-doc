"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3575],{3905:(e,t,n)=>{n.d(t,{Zo:()=>i,kt:()=>d});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},i=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},k="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,i=u(e,["components","mdxType","originalType","parentName"]),k=s(n),c=l,d=k["".concat(o,".").concat(c)]||k[c]||m[c]||r;return n?a.createElement(d,p(p({ref:t},i),{},{components:n})):a.createElement(d,p({ref:t},i))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,p=new Array(r);p[0]=c;var u={};for(var o in t)hasOwnProperty.call(t,o)&&(u[o]=t[o]);u.originalType=e,u[k]="string"==typeof e?e:l,p[1]=u;for(var s=2;s<r;s++)p[s]=n[s];return a.createElement.apply(null,p)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7606:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>p,default:()=>k,frontMatter:()=>r,metadata:()=>u,toc:()=>s});var a=n(3117),l=(n(7294),n(3905));const r={title:"Combining pattern structure",permalink:"wiki/Combining_pattern_structure/",layout:"wiki",tags:["Tidal-1+","Reference"]},p="Combining numerical patterns",u={unversionedId:"working-with-patterns/Combining_pattern_structure",id:"working-with-patterns/Combining_pattern_structure",title:"Combining pattern structure",description:"A core feature of Tidal is the ease in which two patterns can be",source:"@site/docs/working-with-patterns/Combining_pattern_structure.md",sourceDirName:"working-with-patterns",slug:"/working-with-patterns/Combining_pattern_structure",permalink:"/docs/working-with-patterns/Combining_pattern_structure",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/working-with-patterns/Combining_pattern_structure.md",tags:[{label:"Tidal-1+",permalink:"/docs/tags/tidal-1"},{label:"Reference",permalink:"/docs/tags/reference"}],version:"current",lastUpdatedBy:"Joan Queralt",lastUpdatedAt:1672072030,formattedLastUpdatedAt:"Dec 26, 2022",frontMatter:{title:"Combining pattern structure",permalink:"wiki/Combining_pattern_structure/",layout:"wiki",tags:["Tidal-1+","Reference"]}},o={},s=[{value:"Structure from the left",id:"structure-from-the-left",level:2},{value:"Structure from the right",id:"structure-from-the-right",level:2},{value:"All the operators",id:"all-the-operators",level:2}],i={toc:s};function k(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},i,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"combining-numerical-patterns"},"Combining numerical patterns"),(0,l.kt)("p",null,"A core feature of Tidal is the ease in which two patterns can be\ncombined."),(0,l.kt)("p",null,"For example, these are two patterns being combined by adding together\ntheir elements:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'"2 3" + "4 5 6"\n')),(0,l.kt)("p",null,"The result of the above is equivalent to the pattern"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'"6 [7 8] 9"\n')),(0,l.kt)("p",null,". But why?"),(0,l.kt)("p",null,"Let's look closer. The two patterns line up over time like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  |  2  |  3  |\n+ | 4 | 5 | 6 |\n")),(0,l.kt)("p",null,"Unlike in previous versions of Tidal, when you combine two patterns in\nthis way, by default the structure now comes from ",(0,l.kt)("em",{parentName:"p"},"both patterns"),". This\nmeans you end up with ",(0,l.kt)("em",{parentName:"p"},"four")," events, because the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"5\n")),(0,l.kt)("p",null,"in the middle lines up both with the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),(0,l.kt)("p",null,"and the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),(0,l.kt)("p",null,", and gets split in half between them. We can add the resulting pattern\nto our table:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"  |  2  |  3  |\n+ | 4 | 5 | 6 |\n= | 6 |7|8| 9 |\n")),(0,l.kt)("p",null,"You can see that the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"4\n")),(0,l.kt)("p",null,"fits inside"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),(0,l.kt)("p",null,", so where they intersect, you get a new event equal to their sum"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"6\n")),(0,l.kt)("p",null,"."),(0,l.kt)("p",null,"Also see that the event with value"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"5\n")),(0,l.kt)("p",null,"is cut in half, to create two, shorter events. Half matches with the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),(0,l.kt)("p",null,"event and the other half matches with the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),(0,l.kt)("p",null,"event."),(0,l.kt)("p",null,"The fourth and final event comes from the intersection of"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),(0,l.kt)("p",null,"and"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"6\n")),(0,l.kt)("p",null,", giving a value of"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"9\n")),(0,l.kt)("p",null,"."),(0,l.kt)("h2",{id:"structure-from-the-left"},"Structure from the left"),(0,l.kt)("p",null,"In previous versions of Tidal, the structure always came from the left.\nYou can still do this, but in this case using"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"|+\n")),(0,l.kt)("p",null,"."),(0,l.kt)("p",null,"For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'"2 3" |+ "4 5 6"\n')),(0,l.kt)("p",null,"In the above example, you end up with structure from the first\n(leftmost) pattern, like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"   |  2  |  3  |\n|+ | 4 | 5 | 6 |\n = |  6  |  8  |\n")),(0,l.kt)("p",null,"You can see the structure comes from the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),(0,l.kt)("p",null,"and"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),(0,l.kt)("p",null,"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),(0,l.kt)("p",null,"lines up with"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"4\n")),(0,l.kt)("p",null,", and the start of"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),(0,l.kt)("p",null,"is in"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"5\n")),(0,l.kt)("p",null,", so you end up with"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"2+4=6\n")),(0,l.kt)("p",null,"and"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"3+5=8\n")),(0,l.kt)("p",null,". The result is the equivalent of"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'"6 8"\n')),(0,l.kt)("h2",{id:"structure-from-the-right"},"Structure from the right"),(0,l.kt)("p",null,"Likewise, you can take the structure from the right, with"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"+|\n")),(0,l.kt)("p",null,". So"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'"2\n3" +| "4 5 6"\n')),(0,l.kt)("p",null,"looks like:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"   |  2  |  3  |\n+| | 4 | 5 | 6 |\n = | 6 | 7 | 9 |\n")),(0,l.kt)("p",null,"The result is the equivalent of"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'"6 7 9"\n')),(0,l.kt)("p",null,"."),(0,l.kt)("h2",{id:"all-the-operators"},"All the operators"),(0,l.kt)("p",null,"So far, we've just looked at"),(0,l.kt)("p",null,"Note that"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"+\n")),(0,l.kt)("p",null,"is actually an alias for"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"|+|\n")),(0,l.kt)("p",null,". So"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"|+\n")),(0,l.kt)("p",null,"is to take the structure from the left,"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"+|\n")),(0,l.kt)("p",null,"from the right, and"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"|+|\n")),(0,l.kt)("p",null,"or"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"+\n")),(0,l.kt)("p",null,"for both. Here are the basic operators you can use to combine numerical\npatterns:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Function"),(0,l.kt)("th",{parentName:"tr",align:null},"Both"),(0,l.kt)("th",{parentName:"tr",align:null},"Left"),(0,l.kt)("th",{parentName:"tr",align:null},"Right"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Add"),(0,l.kt)("td",{parentName:"tr",align:null},"|","+","|","(or +)"),(0,l.kt)("td",{parentName:"tr",align:null},"|","+"),(0,l.kt)("td",{parentName:"tr",align:null},"+","|")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Subtract"),(0,l.kt)("td",{parentName:"tr",align:null},"|","-","|","(or -)"),(0,l.kt)("td",{parentName:"tr",align:null},"|","-"),(0,l.kt)("td",{parentName:"tr",align:null},"-","|")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Multiply"),(0,l.kt)("td",{parentName:"tr",align:null},"|",(0,l.kt)("em",{parentName:"td"},"|","(or "),")"),(0,l.kt)("td",{parentName:"tr",align:null},"|","*"),(0,l.kt)("td",{parentName:"tr",align:null},"*","|")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Divide"),(0,l.kt)("td",{parentName:"tr",align:null},"|","/","|","(or /)"),(0,l.kt)("td",{parentName:"tr",align:null},"|","/"),(0,l.kt)("td",{parentName:"tr",align:null},"/","|")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Modulo"),(0,l.kt)("td",{parentName:"tr",align:null},"|","%","|"),(0,l.kt)("td",{parentName:"tr",align:null},"|","%"),(0,l.kt)("td",{parentName:"tr",align:null},"%","|")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Left values"),(0,l.kt)("td",{parentName:"tr",align:null},"|","<","|"),(0,l.kt)("td",{parentName:"tr",align:null},"|","<"),(0,l.kt)("td",{parentName:"tr",align:null},"<","|")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Right values"),(0,l.kt)("td",{parentName:"tr",align:null},"|",">","|"),(0,l.kt)("td",{parentName:"tr",align:null},"|",">"),(0,l.kt)("td",{parentName:"tr",align:null},">","|")))),(0,l.kt)("p",null,"The last two are interesting, they let you only take values from one\nside. So for example you could take structure from the left, but values\nfrom the right with"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"|>\n")),(0,l.kt)("p",null,", for example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"   |  2  |  3  |\n|> | 4 | 5 | 6 |\n = |  4  |  5  |\n")),(0,l.kt)("p",null,"This is very similar to how"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"|+|\n")),(0,l.kt)("p",null,"used to work in the versions of tidal prior to 1.0.0 - it took structure\nfrom the left, but values from the right. In fact,"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"#\n")),(0,l.kt)("p",null,"is an alias for"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},"|>\n")),(0,l.kt)("p",null,", mirroring the behaviour in previous versions of tidal."),(0,l.kt)("h1",{id:"combining-control-patterns"},"Combining control patterns"),(0,l.kt)("p",null,"A control pattern (formerly known as a 'param pattern'), is a pattern\nthat's been given a control name. For example the number pattern"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'"1 2 3"\n')),(0,l.kt)("p",null,"can be turned into a control pattern like this"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'speed "1 2 3"\n')),(0,l.kt)("p",null,"."),(0,l.kt)("p",null,"Control patterns can be combined together in the same way as numerical\npatterns. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum" |+| n "1 2 3"\n')),(0,l.kt)("p",null,"Nothing actually gets added together in the above, they're just combined\ninto the equivalent of"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum:1 drum:2 drum:3"\n')),(0,l.kt)("p",null,". However if you specify the same numerical control more than once, then\ntheir values ","_","will","_"," be combined. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum" |+| n "2 3" |+| n "4 5 6"\n')),(0,l.kt)("p",null,"The above will be equivalent to:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum" |+| n "6 [7 8] 9"\n')))}k.isMDXComponent=!0}}]);