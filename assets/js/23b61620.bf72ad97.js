(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{219:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return u}));var a=t(0),l=t.n(a);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=l.a.createContext({}),b=function(e){var n=l.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=b(e.components);return l.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return l.a.createElement(l.a.Fragment,{},n)}},m=l.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=b(t),m=a,u=p["".concat(r,".").concat(m)]||p[m]||d[m]||o;return t?l.a.createElement(u,i(i({ref:n},s),{},{components:t})):l.a.createElement(u,i({ref:n},s))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var s=2;s<o;s++)r[s]=t[s];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},94:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return i})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return b}));var a=t(3),l=t(7),o=(t(0),t(219)),r={title:"Randomness",id:"randomness"},i={unversionedId:"reference/randomness",id:"reference/randomness",isDocsHomePage:!1,title:"Randomness",description:"This page will present you all the functions that can be used to introduce some randomness in your musical patterns. Each function will be presented following the same model:",source:"@site/docs/reference/randomness.md",slug:"/reference/randomness",permalink:"/docs/reference/randomness",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/reference/randomness.md",version:"current",lastUpdatedBy:"Renzo Torr-",lastUpdatedAt:1664855907,sidebar:"reference",previous:{title:"Sampling",permalink:"/docs/reference/sampling"},next:{title:"Composition",permalink:"/docs/reference/composition"}},c=[{value:"Pseudo-randomisation",id:"pseudo-randomisation",children:[{value:"rand",id:"rand",children:[]},{value:"irand",id:"irand",children:[]}]},{value:"Perlin noise",id:"perlin-noise",children:[{value:"perlin",id:"perlin",children:[]},{value:"perlinWith",id:"perlinwith",children:[]},{value:"perlin2",id:"perlin2",children:[]},{value:"perlin2With",id:"perlin2with",children:[]}]},{value:"The &quot;sometimes&quot; family",id:"the-sometimes-family",children:[{value:"sometimes",id:"sometimes",children:[]},{value:"sometimesBy",id:"sometimesby",children:[]},{value:"someCycles",id:"somecycles",children:[]},{value:"someCyclesBy",id:"somecyclesby",children:[]}]},{value:"Choosing randomly",id:"choosing-randomly",children:[{value:"choose",id:"choose",children:[]},{value:"chooseby",id:"chooseby",children:[]},{value:"wchoose",id:"wchoose",children:[]},{value:"wchooseby",id:"wchooseby",children:[]},{value:"cycleChoose",id:"cyclechoose",children:[]}]}],s={toc:c};function b(e){var n=e.components,t=Object(l.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This page will present you all the functions that can be used to introduce some randomness in your musical patterns. Each function will be presented following the same model:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Type signature"),": how the function is declared on the ",Object(o.b)("strong",{parentName:"li"},"Haskell")," side."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Description"),": verbal description of the function."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"Examples"),": a small list of examples that you can copy/paste in your editor.")),Object(o.b)("h2",{id:"pseudo-randomisation"},"Pseudo-randomisation"),Object(o.b)("h3",{id:"rand"},"rand"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: rand :: Fractional a => Pattern a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"rand")," is an oscillator that generates a pattern of (pseudo-)random, floating point numbers between ",Object(o.b)("inlineCode",{parentName:"p"},"0.0")," and ",Object(o.b)("inlineCode",{parentName:"p"},"1.0"),". For example to randomly pan around the stereo field you can:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd*8" # pan rand\n')),Object(o.b)("p",null,"Or to enjoy a randomised speed from ",Object(o.b)("inlineCode",{parentName:"p"},"0.5")," to ",Object(o.b)("inlineCode",{parentName:"p"},"1.5"),", you can add ",Object(o.b)("inlineCode",{parentName:"p"},"0.5")," to it."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "arpy*4" # speed (rand + 0.5)\n')),Object(o.b)("h3",{id:"irand"},"irand"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: irand :: Num a => Int -> Pattern a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"irand")," is similar to ",Object(o.b)("inlineCode",{parentName:"p"},"rand"),", but generates a continuous oscillator of (pseudo-)random integers between ",Object(o.b)("inlineCode",{parentName:"p"},"0")," to ",Object(o.b)("inlineCode",{parentName:"p"},"n-1")," inclusive. Notably used to pick random samples from a folder."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "amencutup*8" # n (irand 8)\n')),Object(o.b)("h2",{id:"perlin-noise"},"Perlin noise"),Object(o.b)("h3",{id:"perlin"},"perlin"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: perlin :: Pattern Double\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"perlin")," produces 1D Perlin (smooth) noise. It works like rand but smoothly moves between random values each cycle. For example, you can smoothly and randomly change speed:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd*32" # speed (perlin + 0.5)\n')),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"perlin")," function produces a new random value to move to every cycle. If you want a new random value to be generated more or less frequently, you can use ",Object(o.b)("inlineCode",{parentName:"p"},"fast")," or ",Object(o.b)("inlineCode",{parentName:"p"},"slow"),", respectively:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd*32" # speed (fast 4 $ perlin + 0.5)\nd1 $ sound "bd*32" # speed (slow 4 $ perlin + 0.5)\n')),Object(o.b)("h3",{id:"perlinwith"},"perlinWith"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"perlinWith")," allows you to specify a pattern as input to generate random values instead of using the default cycle count:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ s "arpy*32" # cutoff (perlinWith (saw * 4) * 2000)\n')),Object(o.b)("h3",{id:"perlin2"},"perlin2"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"perlin2")," creates 2D noise by allowing you to specify a custom pattern as a second dimension (cycle number remains as the first dimension):"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ s "bd*32" # speed (perlin2 (sine*4) + 1)\n')),Object(o.b)("h3",{id:"perlin2with"},"perlin2With"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"perlin2With")," is the same as ",Object(o.b)("inlineCode",{parentName:"p"},"perlinWith")," except allows you to provide two functions for 2D noise:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1\n $ s "[arpy*32]"\n # lpf (range 60 5000 $ perlin2With (cosine*2) (sine*2))\n # lpq 0.3\n')),Object(o.b)("h2",{id:"the-sometimes-family"},'The "sometimes" family'),Object(o.b)("h3",{id:"sometimes"},"sometimes"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: sometimes :: (Pattern a -> Pattern a) -> Pattern a -> Pattern a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"sometimes")," is function, that applies another function to a pattern, around 50% of the time, at random. It takes two inputs, the function to be applied, and the pattern you are applying it to."),Object(o.b)("p",null,"For example to distort half the events in a pattern:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sometimes (# crush 2) $ n "0 1 [~ 2] 3" # sound "arpy"\n')),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"sometimes")," has a number of variants, which apply the function with different likelihood: "),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",{parentName:"tr",align:null},"function"),Object(o.b)("th",{parentName:"tr",align:null},"\xa0likelihood"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"always"),Object(o.b)("td",{parentName:"tr",align:null},"100%")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"almostAlways"),Object(o.b)("td",{parentName:"tr",align:null},"90%")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"often"),Object(o.b)("td",{parentName:"tr",align:null},"75%")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"sometimes"),Object(o.b)("td",{parentName:"tr",align:null},"50%")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"rarely"),Object(o.b)("td",{parentName:"tr",align:null},"25%")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"almostNever"),Object(o.b)("td",{parentName:"tr",align:null},"10%")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",{parentName:"tr",align:null},"never"),Object(o.b)("td",{parentName:"tr",align:null},"0%")))),Object(o.b)("h3",{id:"sometimesby"},"sometimesBy"),Object(o.b)("p",null,"If you want to be specific, you can use ",Object(o.b)("inlineCode",{parentName:"p"},"sometimesBy")," and a number, for example:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"sometimesBy 0.93 (# speed 2)\n")),Object(o.b)("p",null,"to apply the speed control on average 93 times out of a hundred."),Object(o.b)("h3",{id:"somecycles"},"someCycles"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"someCycles")," is similar to ",Object(o.b)("inlineCode",{parentName:"p"},"sometimes"),", but instead of applying the given function to random events, it applies it to random cycles. For example the following will either distort all of the events in a cycle, or none of them:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ someCycles (# crush 2) $ n "0 1 [~ 2] 3" # sound "arpy"\n')),Object(o.b)("h3",{id:"somecyclesby"},"someCyclesBy"),Object(o.b)("p",null,"As with ",Object(o.b)("inlineCode",{parentName:"p"},"sometimesBy"),", if you want to be specific, you can use ",Object(o.b)("inlineCode",{parentName:"p"},"someCyclesBy")," and a number. For example:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"someCyclesBy 0.93 (# speed 2)\n")),Object(o.b)("p",null,"will apply the speed control on average ",Object(o.b)("inlineCode",{parentName:"p"},"93")," cycles out of a hundred."),Object(o.b)("h2",{id:"choosing-randomly"},"Choosing randomly"),Object(o.b)("h3",{id:"choose"},"choose"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: choose :: [a] -> Pattern a\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"choose")," function emits a stream of randomly choosen values from the given list, as a continuous pattern:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum ~ drum drum" # n (choose [0,2,3])\n')),Object(o.b)("p",null,"As with all continuous patterns, you have to be careful to give them structure; in this case choose gives you an infinitely detailed stream of random choices. "),Object(o.b)("h3",{id:"chooseby"},"chooseby"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: chooseBy :: Pattern Double -> [a] -> Pattern a\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"chooseBy")," function is like choose but instead of selecting elements of the list randomly, it uses the given pattern to select elements."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'chooseBy "0 0.25 0.5" ["a","b","c","d"]\n')),Object(o.b)("p",null,"will result in the pattern ",Object(o.b)("inlineCode",{parentName:"p"},'"a b c" '),"."),Object(o.b)("h3",{id:"wchoose"},"wchoose"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: wchoose :: [(a, Double)] -> Pattern a\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"wchoose")," is similar to ",Object(o.b)("inlineCode",{parentName:"p"},"choose"),", but allows you to 'weight' the choices, so some are more likely to be chosen than others. The following is similar to the previous example, but the ",Object(o.b)("inlineCode",{parentName:"p"},"2")," is twice as likely to be chosen than the ",Object(o.b)("inlineCode",{parentName:"p"},"0")," or ",Object(o.b)("inlineCode",{parentName:"p"},"3"),"."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum ~ drum drum" # n (wchoose [(0,0.25),(2,0.5),(3,0.25)])\n')),Object(o.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(o.b)("div",{parentName:"div",className:"admonition-heading"},Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",{parentName:"h5",className:"admonition-icon"},Object(o.b)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},Object(o.b)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),Object(o.b)("div",{parentName:"div",className:"admonition-content"},Object(o.b)("p",{parentName:"div"},"Prior to version ",Object(o.b)("inlineCode",{parentName:"p"},"1.0.0")," of ",Object(o.b)("strong",{parentName:"p"},"Tidal"),", the weights had to add up to ",Object(o.b)("inlineCode",{parentName:"p"},"1"),", but this is no longer the case. "))),Object(o.b)("h3",{id:"wchooseby"},"wchooseby"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: wchooseBy :: Pattern Double -> [(a,Double)] -> Pattern a\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"wchooseBy")," function is like ",Object(o.b)("inlineCode",{parentName:"p"},"wchoose")," but instead of selecting elements of the list randomly, it uses the given pattern to select elements. "),Object(o.b)("h3",{id:"cyclechoose"},"cycleChoose"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},"Type: cycleChoose :: [a] -> Pattern a\n")),Object(o.b)("p",null,"Similar to ",Object(o.b)("inlineCode",{parentName:"p"},"choose"),", but only picks once per cycle:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "drum ~ drum drum" # n (cycleChoose [0,2,3])\n')))}b.isMDXComponent=!0}}]);