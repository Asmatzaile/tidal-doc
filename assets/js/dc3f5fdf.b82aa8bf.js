(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{194:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(3),i=n(7),r=(n(0),n(217)),l={title:"MIDI",id:"midi",permalink:"wiki/MIDI/",layout:"wiki"},o={unversionedId:"configuration/MIDIOSC/midi",id:"configuration/MIDIOSC/midi",isDocsHomePage:!1,title:"MIDI",description:"Tidal can send and receive MIDI messages. You can talk with external synthesizers and hardware and receive data from your controllers. All the mapping is done directly through the language in an intuitive way.",source:"@site/docs/configuration/MIDIOSC/MIDI.md",slug:"/configuration/MIDIOSC/midi",permalink:"/docs/configuration/MIDIOSC/midi",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/configuration/MIDIOSC/MIDI.md",version:"current",lastUpdatedBy:"callnasty",lastUpdatedAt:1651580836,sidebar:"docs",previous:{title:"Adding Synthesizers",permalink:"/docs/configuration/adding_synthesizers"},next:{title:"OSC",permalink:"/docs/configuration/MIDIOSC/osc"}},c=[{value:"SuperDirt MIDI",id:"superdirt-midi",children:[{value:"Prerequisites",id:"prerequisites",children:[]},{value:"Initialization",id:"initialization",children:[]},{value:"Usage in Tidal",id:"usage-in-tidal",children:[]}]},{value:"Tidal-Midi",id:"tidal-midi",children:[{value:"Synchronising MIDI clock",id:"synchronising-midi-clock",children:[]}]},{value:"Controller Input",id:"controller-input",children:[{value:"Setup",id:"setup",children:[]},{value:"Usage",id:"usage",children:[]},{value:"Renaming MIDI notes",id:"renaming-midi-notes",children:[]},{value:"Alternative with Pure Data",id:"alternative-with-pure-data",children:[]}]}],s={toc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Tidal can send and receive MIDI messages. You can talk with external synthesizers and hardware and receive data from your controllers. All the mapping is done directly through the language in an intuitive way."),Object(r.b)("h2",{id:"superdirt-midi"},"SuperDirt MIDI"),Object(r.b)("h3",{id:"prerequisites"},"Prerequisites"),Object(r.b)("p",null,"The prerequisites require recent versions of ",Object(r.b)("strong",{parentName:"p"},"Tidal")," and ",Object(r.b)("strong",{parentName:"p"},"SuperDirt"),":"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Upgrade to the latest Tidal (this post assumes version 0.9.10 or greater)"),Object(r.b)("li",{parentName:"ul"},"Make sure you have the latest ",Object(r.b)("strong",{parentName:"li"},"SuperDirt quark"),". Uninstalling and reinstalling the SuperDirt quark might be easiest. See ",Object(r.b)("a",{parentName:"li",href:"github.com/supercollider-quarks/quarks"},"this page")," for details on how to update Quarks.")),Object(r.b)("h3",{id:"initialization"},"Initialization"),Object(r.b)("p",null,"To begin, you'll start in ",Object(r.b)("strong",{parentName:"p"},"SuperCollider"),". Start up ",Object(r.b)("strong",{parentName:"p"},"SuperDirt")," as you normally would. Then, in SuperCollider eval the following code:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"MIDIClient.init;\n")),Object(r.b)("p",null,"You should now see a list of the system MIDI devices in ",Object(r.b)("strong",{parentName:"p"},"SuperCollider"),"'s post window. The output will look something like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'MIDI Sources:\n    MIDIEndPoint("LoopBe Internal MIDI", "LoopBe Internal MIDI")\n    MIDIEndPoint("Focusrite USB MIDI", "Focusrite USB MIDI")\nMIDI Destinations:\n    MIDIEndPoint("Microsoft GS Wavetable Synth", "Microsoft GS Wavetable Synth")\n    MIDIEndPoint("LoopBe Internal MIDI", "LoopBe Internal MIDI")\n    MIDIEndPoint("Focusrite USB MIDI", "Focusrite USB MIDI")\n')),Object(r.b)("p",null,"Take note that these MIDI devices have two parts to their names. You will need both parts in the next step, which is to actually connect to the MIDI device. Eval the following line:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'~midiOut = MIDIOut.newByName("Focusrite USB MIDI", "Focusrite USB MIDI"); // substitute your own device here\n')),Object(r.b)("p",null,"Above, we have stored a reference to the device in a variable named ",Object(r.b)("inlineCode",{parentName:"p"},"~midiOut"),"."),Object(r.b)("p",null,'Finally, define the name of the "synth" in Tidal you will use to control this device. Below, we will call it "midi". Eval the following line:'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"~dirt.soundLibrary.addMIDI(\\midi, ~midiOut);\n")),Object(r.b)("p",null,"Optionally, you can define a latency value on your device:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"~midiOut.latency = 0.45;\n")),Object(r.b)("p",null,'That\'s it for initialization. You should now have a MIDI device connected in SuperDirt, running as a synth named "midi".'),Object(r.b)("h3",{id:"usage-in-tidal"},"Usage in Tidal"),Object(r.b)("h4",{id:"note-patterns"},"Note Patterns"),Object(r.b)("p",null,"Now we can start writing some Tidal patterns to control the MIDI device. Let's send it a trivial note pattern:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d1 $ n "0 2 4 7" # s "midi"\n')),Object(r.b)("p",null,'That should play a simple four-note pattern. Notice we\'re just using the synth name "midi" to send notes to the MIDI device.'),Object(r.b)("p",null,"You can also use the note-name and octave notation:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d1 $ n "c4 d4 e5 g3" # s "midi"\n')),Object(r.b)("h4",{id:"midi-channels"},"MIDI Channels"),Object(r.b)("p",null,"The default MIDI channel is 1. SuperDirt MIDI channels are indexed starting at zero, so MIDI channel 1 is midichan 0:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d1 $ note "0 2 4 7" # s "midi" # midichan 0\n')),Object(r.b)("p",null,"If your synth is listening on a different channel, let's say, MIDI channel 5, you would use midichan 4:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d1 $ note "0 2 4 7" # s "midi" # midichan 4\n')),Object(r.b)("p",null,"Notice that midichan accepts a pattern of numbers, so you can use a pattern to play on different MIDI channels:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d1 $ note "0 2 4 7" # s "midi" # midichan "0 4"\n')),Object(r.b)("p",null,'The above pattern plays notes "0 2" on channel 1 and "4 7" on channel 5.'),Object(r.b)("h4",{id:"cc-params"},"CC Params"),Object(r.b)("p",null,"To send a CC param to your synth, the best way to do it in the new SuperDirt MIDI is with a different Tidal pattern. To create this pattern, you'll be using two new SuperDirt MIDI params:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"ccn"),": the CC param number you want to control: ccn 30"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"ccv"),": the value to send to the CC param, ranging from 0 to 127: ccv 64")),Object(r.b)("p",null,"Here's a full example, sending a value of 64 to CC param 30:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d2 $ ccv 64 # ccn 30 # s "midi"\n')),Object(r.b)("p",null,"You can of course also specify the MIDI channel with midichan:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d2 $ ccv 64 # ccn 30 # s "midi" # midichan 4\n')),Object(r.b)("p",null,"You can specify patterns of CC values:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d2 $ ccv "20 40 60 80 100" # ccn 30 # s "midi"\n\nd2 $ ccn "30*4" # ccv (range 20 100 $ slow 30 sine) # s "midi"\n')),Object(r.b)("p",null,"Note that the left-most pattern defines the rhythm in this case when using ",Object(r.b)("inlineCode",{parentName:"p"},"#"),"."),Object(r.b)("p",null,"If you have a specific feature on your device that listens on a specific CC number, you can give it a friendly name if you wish:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'let ringMod = 30\nd2 $ ccv "0 20 50 60" # ccn ringMod # s "midi"\n')),Object(r.b)("p",null,"If you have many CC params you want to control at once, a stack works well:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'d2 $ density 8 $ stack [\n  ccn 30 # ccv (range 0 127 $ slow 30 sine),\n  ccn 31 # ccv "[0 70 30 110]/3",\n  ccn 32 # ccv 10\n  ] # s "midi"\n')),Object(r.b)("h2",{id:"tidal-midi"},"Tidal-Midi"),Object(r.b)("p",null,"The older ",Object(r.b)("inlineCode",{parentName:"p"},"tidal-midi")," Haskell module is not currently working (although it might return). Use the other existing solutions."),Object(r.b)("h3",{id:"synchronising-midi-clock"},"Synchronising MIDI clock"),Object(r.b)("p",null,"Once you've set up ",Object(r.b)("strong",{parentName:"p"},"SuperDirt MIDI")," by following the tutorial, sending ",Object(r.b)("inlineCode",{parentName:"p"},"midiclock")," is fairly straightforward and works well, although still in development. This will become easier still in the future."),Object(r.b)("p",null,"First, you can start sending MIDI clock messages, 48 per cycle, like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'p "midiclock" $ midicmd "midiClock*48" # s "midi"\n')),Object(r.b)("p",null,"Your MIDI device should then adjust its BPM to Tidal's cps. Then it's worth sending a ",Object(r.b)("inlineCode",{parentName:"p"},"stop")," message like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'once $ midicmd "stop" # s "midi"\n')),Object(r.b)("p",null,"and then finally a start message to start the MIDI clock at the right time. The following sends a start message every fourth cycle:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'p "midictl" $ midicmd "start/4" # s "midi"\n\n')),Object(r.b)("p",null,"Once everything's started and in sync, it's probably best to stop sending the start messages to avoid glitching:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'p "midictl" $ silence\n')),Object(r.b)("p",null,"However now if you do hush, the ",Object(r.b)("inlineCode",{parentName:"p"},"midiclock")," will stop as well as all the other patterns. To avoid this, you can overwrite the hush function with a version that silences particular patterns:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},"let hush = mapM_ ($ silence) [d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16]\n")),Object(r.b)("p",null,"You will probably find that the downbeats for SuperDirt and your MIDI devices don't align. As a starting point, set MIDI latency in supercollider to 0:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-supercollider"},"~midiOut.latency = 0;\n")),Object(r.b)("p",null,"Make sure any offset on the MIDI side is also set to 0, then gradually adjust one of them until they align. If they stay in alignment when you change the cps, all is good!"),Object(r.b)("h2",{id:"controller-input"},"Controller Input"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Tidal")," 1.0.0 now has support for external input, using the OSC protocol. Here's a quick guide to getting it going, including using a simple 'bridge' for getting MIDI input working."),Object(r.b)("h3",{id:"setup"},"Setup"),Object(r.b)("p",null,"To use MIDI, you don't have to worry too much about mapping OSC. However, you do have to run something to convert MIDI into OSC (",Object(r.b)("strong",{parentName:"p"},"Tidal")," is listening for OSC messages). Here's how to do that using SuperCollider. First, with ",Object(r.b)("strong",{parentName:"p"},"Tidal")," and ",Object(r.b)("strong",{parentName:"p"},"SuperDirt")," already running, run the below code block in ",Object(r.b)("strong",{parentName:"p"},"SuperCollider"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-c"},'// Evaluate the block below to start the mapping MIDI -> OSC.\n(\nvar on, off, cc;\nvar osc;\n\nosc = NetAddr.new("127.0.0.1", 6010);\n\nMIDIClient.init;\nMIDIIn.connectAll;\n\non = MIDIFunc.noteOn({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, val/127);\n});\n\noff = MIDIFunc.noteOff({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, 0);\n});\n\ncc = MIDIFunc.cc({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, val/127);\n});\n\nif (~stopMidiToOsc != nil, {\n    ~stopMidiToOsc.value;\n});\n\n~stopMidiToOsc = {\n    on.free;\n    off.free;\n    cc.free;\n};\n)\n\n// Evaluate the line below to stop it.\n~stopMidiToOsc.value;\n')),Object(r.b)("h3",{id:"usage"},"Usage"),Object(r.b)("p",null,"You should then be able to run a pattern such as the following, that uses ",Object(r.b)("inlineCode",{parentName:"p"},"CC value 12"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd" # speed (cF 1 "12")\n')),Object(r.b)("p",null,"If you want to use MIDI in a pattern forming statement, you may find it helpful to ",Object(r.b)("inlineCode",{parentName:"p"},"segment")," the input first, as the raw pattern coming from your MIDI device will be at very high resolution. This example takes only one value per cycle & remaps the value with the ",Object(r.b)("inlineCode",{parentName:"p"},"range")," function:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "amencutup" + n (run (segment 1 $ range 1 16 $ cN 0 "32" ))\n')),Object(r.b)("h3",{id:"renaming-midi-notes"},"Renaming MIDI notes"),Object(r.b)("p",null,"In case you have a MIDI drum machine, where the bassdrum is on MIDI note 231 and you don't want to write ",Object(r.b)("inlineCode",{parentName:"p"},"231")," every time, you could either do this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},'s2n :: String -> Note\ns2n "BD" = 231\ns2n _ = 0\n\nd1 $ n (s2n <$> "BD*4") # sound "tr8" # midichan 9\n')),Object(r.b)("p",null,"Another approach is using ",Object(r.b)("inlineCode",{parentName:"p"},"inhabit"),", you pass it a list of names and patterns, like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("sd", "232")] pat)\n')),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},'d1 $ drum "bd sd" # midichan 9\n')),Object(r.b)("p",null,"You could also hide the midi channel in there so you don't have to type it each time"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("sd", "232")] pat) # midichan 9\n\nd1 $ drum "bd sd"\nd2 $ drum "bd*3 sd*2"\n')),Object(r.b)("p",null,"Note that the ",Object(r.b)("inlineCode",{parentName:"p"},"232")," bit is a pattern, so you could have one name trigger more than one event e.g."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("rush", "232*8"), ("sd", "232")] pat) # midichan 9\n\nd1 $ drum "bd sd rush"\n')),Object(r.b)("h3",{id:"alternative-with-pure-data"},"Alternative with Pure Data"),Object(r.b)("p",null,"The above ",Object(r.b)("strong",{parentName:"p"},"SuperCollider")," instructions are most convenient if you're using ",Object(r.b)("strong",{parentName:"p"},"SuperDirt"),", but as an alternative you can use ",Object(r.b)("strong",{parentName:"p"},"Pure Data")," to convert midi to ",Object(r.b)("strong",{parentName:"p"},"OSC"),". You can get puredata from ",Object(r.b)("a",{parentName:"p",href:"https://puredata.info/"},"here")," (the ",Object(r.b)("inlineCode",{parentName:"p"},"vanilla")," version is recommended). Then, download ",Object(r.b)("a",{parentName:"p",href:"https://raw.githubusercontent.com/tidalcycles/Tidal/main/pd/midi-osc-bridge.pd"},"this file"),". Then if you start ",Object(r.b)("strong",{parentName:"p"},"Tidal"),", open that file in ",Object(r.b)("strong",{parentName:"p"},"Pure Data"),", and configure your ",Object(r.b)("strong",{parentName:"p"},"MIDI")," device in ",Object(r.b)("strong",{parentName:"p"},"Pure Data"),", things should start working."))}u.isMDXComponent=!0},217:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),u=function(e){var t=i.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return i.a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=u(n),b=a,m=d["".concat(l,".").concat(b)]||d[b]||p[b]||r;return n?i.a.createElement(m,o(o({ref:t},s),{},{components:n})):i.a.createElement(m,o({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=b;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var s=2;s<r;s++)l[s]=n[s];return i.a.createElement.apply(null,l)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);