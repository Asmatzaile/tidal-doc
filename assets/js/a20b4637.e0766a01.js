(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{145:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return b})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return o}));var a=n(3),l=n(7),r=(n(0),n(196)),b={title:"Combining pattern structure",permalink:"wiki/Combining_pattern_structure/",layout:"wiki",tags:["Tidal-1+","Reference"]},c={unversionedId:"working-with-patterns/Combining_pattern_structure",id:"working-with-patterns/Combining_pattern_structure",isDocsHomePage:!1,title:"Combining pattern structure",description:"Combining numerical patterns",source:"@site/docs/working-with-patterns/Combining_pattern_structure.md",slug:"/working-with-patterns/Combining_pattern_structure",permalink:"/docs/working-with-patterns/Combining_pattern_structure",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/working-with-patterns/Combining_pattern_structure.md",version:"current",lastUpdatedBy:"Koji Ishimoto",lastUpdatedAt:1615136026},u=[{value:"Structure from the left",id:"structure-from-the-left",children:[]},{value:"Structure from the right",id:"structure-from-the-right",children:[]},{value:"All the operators",id:"all-the-operators",children:[]}],p={toc:u};function o(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"combining-numerical-patterns"},"Combining numerical patterns"),Object(r.b)("p",null,"A core feature of Tidal is the ease in which two patterns can be\ncombined."),Object(r.b)("p",null,"For example, these are two patterns being combined by adding together\ntheir elements:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'"2 3" + "4 5 6"\n')),Object(r.b)("p",null,"The result of the above is equivalent to the pattern"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'"6 [7 8] 9"\n')),Object(r.b)("p",null,". But why?"),Object(r.b)("p",null,"Let's look closer. The two patterns line up over time like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"  |  2  |  3  |\n+ | 4 | 5 | 6 |\n")),Object(r.b)("p",null,"Unlike in previous versions of Tidal, when you combine two patterns in\nthis way, by default the structure now comes from ",Object(r.b)("em",{parentName:"p"},"both patterns"),". This\nmeans you end up with ",Object(r.b)("em",{parentName:"p"},"four")," events, because the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"5\n")),Object(r.b)("p",null,"in the middle lines up both with the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),Object(r.b)("p",null,"and the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),Object(r.b)("p",null,", and gets split in half between them. We can add the resulting pattern\nto our table:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"  |  2  |  3  |\n+ | 4 | 5 | 6 |\n= | 6 |7|8| 9 |\n")),Object(r.b)("p",null,"You can see that the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"4\n")),Object(r.b)("p",null,"fits inside"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),Object(r.b)("p",null,", so where they intersect, you get a new event equal to their sum"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"6\n")),Object(r.b)("p",null,"."),Object(r.b)("p",null,"Also see that the event with value"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"5\n")),Object(r.b)("p",null,"is cut in half, to create two, shorter events. Half matches with the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),Object(r.b)("p",null,"event and the other half matches with the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),Object(r.b)("p",null,"event."),Object(r.b)("p",null,"The fourth and final event comes from the intersection of"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),Object(r.b)("p",null,"and"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"6\n")),Object(r.b)("p",null,", giving a value of"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"9\n")),Object(r.b)("p",null,"."),Object(r.b)("h2",{id:"structure-from-the-left"},"Structure from the left"),Object(r.b)("p",null,"In previous versions of Tidal, the structure always came from the left.\nYou can still do this, but in this case using"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"|+\n")),Object(r.b)("p",null,"."),Object(r.b)("p",null,"For example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'"2 3" |+ "4 5 6"\n')),Object(r.b)("p",null,"In the above example, you end up with structure from the first\n(leftmost) pattern, like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"   |  2  |  3  |\n|+ | 4 | 5 | 6 |\n = |  6  |  8  |\n")),Object(r.b)("p",null,"You can see the structure comes from the"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),Object(r.b)("p",null,"and"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),Object(r.b)("p",null,"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"2\n")),Object(r.b)("p",null,"lines up with"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"4\n")),Object(r.b)("p",null,", and the start of"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"3\n")),Object(r.b)("p",null,"is in"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"5\n")),Object(r.b)("p",null,", so you end up with"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"2+4=6\n")),Object(r.b)("p",null,"and"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"3+5=8\n")),Object(r.b)("p",null,". The result is the equivalent of"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'"6 8"\n')),Object(r.b)("h2",{id:"structure-from-the-right"},"Structure from the right"),Object(r.b)("p",null,"Likewise, you can take the structure from the right, with"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"+|\n")),Object(r.b)("p",null,". So"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'"2\n3" +| "4 5 6"\n')),Object(r.b)("p",null,"looks like:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"   |  2  |  3  |\n+| | 4 | 5 | 6 |\n = | 6 | 7 | 9 |\n")),Object(r.b)("p",null,"The result is the equivalent of"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'"6 7 9"\n')),Object(r.b)("p",null,"."),Object(r.b)("h2",{id:"all-the-operators"},"All the operators"),Object(r.b)("p",null,"So far, we've just looked at"),Object(r.b)("p",null,"Note that"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"+\n")),Object(r.b)("p",null,"is actually an alias for"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"|+|\n")),Object(r.b)("p",null,". So"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"|+\n")),Object(r.b)("p",null,"is to take the structure from the left,"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"+|\n")),Object(r.b)("p",null,"from the right, and"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"|+|\n")),Object(r.b)("p",null,"or"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"+\n")),Object(r.b)("p",null,"for both. Here are the basic operators you can use to combine numerical\npatterns:"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Function"),Object(r.b)("th",{parentName:"tr",align:null},"Both"),Object(r.b)("th",{parentName:"tr",align:null},"Left"),Object(r.b)("th",{parentName:"tr",align:null},"Right"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Add"),Object(r.b)("td",{parentName:"tr",align:null},"|","+","|","(or +)"),Object(r.b)("td",{parentName:"tr",align:null},"|","+"),Object(r.b)("td",{parentName:"tr",align:null},"+","|")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Subtract"),Object(r.b)("td",{parentName:"tr",align:null},"|","-","|","(or -)"),Object(r.b)("td",{parentName:"tr",align:null},"|","-"),Object(r.b)("td",{parentName:"tr",align:null},"-","|")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Multiply"),Object(r.b)("td",{parentName:"tr",align:null},"|",Object(r.b)("em",{parentName:"td"},"|","(or "),")"),Object(r.b)("td",{parentName:"tr",align:null},"|","*"),Object(r.b)("td",{parentName:"tr",align:null},"*","|")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Divide"),Object(r.b)("td",{parentName:"tr",align:null},"|","/","|","(or /)"),Object(r.b)("td",{parentName:"tr",align:null},"|","/"),Object(r.b)("td",{parentName:"tr",align:null},"/","|")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Modulo"),Object(r.b)("td",{parentName:"tr",align:null},"|","%","|"),Object(r.b)("td",{parentName:"tr",align:null},"|","%"),Object(r.b)("td",{parentName:"tr",align:null},"%","|")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Left values"),Object(r.b)("td",{parentName:"tr",align:null},"|","<","|"),Object(r.b)("td",{parentName:"tr",align:null},"|","<"),Object(r.b)("td",{parentName:"tr",align:null},"<","|")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Right values"),Object(r.b)("td",{parentName:"tr",align:null},"|",">","|"),Object(r.b)("td",{parentName:"tr",align:null},"|",">"),Object(r.b)("td",{parentName:"tr",align:null},">","|")))),Object(r.b)("p",null,"The last two are interesting, they let you only take values from one\nside. So for example you could take structure from the left, but values\nfrom the right with"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"|>\n")),Object(r.b)("p",null,", for example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"   |  2  |  3  |\n|> | 4 | 5 | 6 |\n = |  4  |  5  |\n")),Object(r.b)("p",null,"This is very similar to how"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"|+|\n")),Object(r.b)("p",null,"used to work in the versions of tidal prior to 1.0.0 - it took structure\nfrom the left, but values from the right. In fact,"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"#\n")),Object(r.b)("p",null,"is an alias for"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},"|>\n")),Object(r.b)("p",null,", mirroring the behaviour in previous versions of tidal."),Object(r.b)("h1",{id:"combining-control-patterns"},"Combining control patterns"),Object(r.b)("p",null,"A control pattern (formerly known as a 'param pattern'), is a pattern\nthat's been given a control name. For example the number pattern"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'"1 2 3"\n')),Object(r.b)("p",null,"can be turned into a control pattern like this"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'speed "1 2 3"\n')),Object(r.b)("p",null,"."),Object(r.b)("p",null,"Control patterns can be combined together in the same way as numerical\npatterns. For example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum" |+| n "1 2 3"\n')),Object(r.b)("p",null,"Nothing actually gets added together in the above, they're just combined\ninto the equivalent of"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum:1 drum:2 drum:3"\n')),Object(r.b)("p",null,". However if you specify the same numerical control more than once, then\ntheir values ","_","will","_"," be combined. For example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum" |+| n "2 3" |+| n "4 5 6"\n')),Object(r.b)("p",null,"The above will be equivalent to:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-Haskell"},'d1 $ sound "drum" |+| n "6 [7 8] 9"\n')))}o.isMDXComponent=!0},196:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return O}));var a=n(0),l=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function b(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?b(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):b(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=l.a.createContext({}),o=function(e){var t=l.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},s=function(e){var t=o(e.components);return l.a.createElement(p.Provider,{value:t},e.children)},i={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},m=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,b=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),s=o(n),m=a,O=s["".concat(b,".").concat(m)]||s[m]||i[m]||r;return n?l.a.createElement(O,c(c({ref:t},p),{},{components:n})):l.a.createElement(O,c({ref:t},p))}));function O(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,b=new Array(r);b[0]=m;var c={};for(var u in t)hasOwnProperty.call(t,u)&&(c[u]=t[u]);c.originalType=e,c.mdxType="string"==typeof e?e:a,b[1]=c;for(var p=2;p<r;p++)b[p]=n[p];return l.a.createElement.apply(null,b)}return l.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);