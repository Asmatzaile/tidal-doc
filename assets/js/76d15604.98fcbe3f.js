(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{134:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return p}));var o=n(3),a=n(7),i=(n(0),n(208)),r={title:"The meaning of .",id:"meaning_of_dot"},l={unversionedId:"innards/meaning_of_dot",id:"innards/meaning_of_dot",isDocsHomePage:!1,title:"The meaning of .",description:"The dot (.) is the Haskell operator for function composition. Function composition comes from mathematics but actually, it can be really useful to make music. Haskell was originally designed by mathematicians and computer magicians. Its syntax borrowed quite a lot from mathematical notation. In some cases, Haskell is sometimes more precise and strict than other languages. The syntax is also much more compact.",source:"@site/docs/innards/meaning_of_dot.md",slug:"/innards/meaning_of_dot",permalink:"/docs/innards/meaning_of_dot",editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/innards/meaning_of_dot.md",version:"current",lastUpdatedBy:"Raphael Forment",lastUpdatedAt:1621872654,sidebar:"docs",previous:{title:"The meaning of $\xa0",permalink:"/docs/innards/meaning_of_dollar"},next:{title:"Type Signatures",permalink:"/docs/innards/type_signatures"}},s=[{value:"Introduction",id:"introduction",children:[]},{value:"The dot",id:"the-dot",children:[]},{value:"Why should I use it?",id:"why-should-i-use-it",children:[]}],c={toc:s};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"The dot (",Object(i.b)("inlineCode",{parentName:"p"},"."),") is the ",Object(i.b)("strong",{parentName:"p"},"Haskell")," operator for function composition. Function composition comes from mathematics but actually, it can be really useful to make music. Haskell was originally designed by mathematicians and computer magicians. Its syntax borrowed quite a lot from mathematical notation. In some cases, Haskell is sometimes more precise and strict than other languages. The syntax is also much more compact. "),Object(i.b)("h2",{id:"introduction"},"Introduction"),Object(i.b)("p",null,"When you make music with ",Object(i.b)("strong",{parentName:"p"},"Tidal"),", you are composing functions: feeding the output of a function to another function, etc... Your function will generally output a pattern that will be parsed and sent to ",Object(i.b)("strong",{parentName:"p"},"SuperDirt")," to turn it into sound. ",Object(i.b)("inlineCode",{parentName:"p"},"$")," is another really useful function composition operator that you are using everytime you play with ",Object(i.b)("strong",{parentName:"p"},"Tidal"),"."),Object(i.b)("p",null,"Tidal functions are small little programs that do very few things. The name is sometimes a good description of the purpose of any given function. ",Object(i.b)("inlineCode",{parentName:"p"},"fast")," will make things faster, ",Object(i.b)("inlineCode",{parentName:"p"},"slow")," will slow them down, ",Object(i.b)("inlineCode",{parentName:"p"},"striate"),' will striate, etc.. By feeding the output of a function to another one, you transform your pattern more and more, until your "composed" and definitive function feels allright for you.'),Object(i.b)("h2",{id:"the-dot"},"The dot"),Object(i.b)("p",null,"The dot is a ",Object(i.b)("inlineCode",{parentName:"p"},"function composition")," operator. Let's take an example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-haskell"},'d1\n  $ fast 2\n  $\xa0s "hh*4"\n')),Object(i.b)("p",null,"This small code snippet will play a fast uninteresting hi-hat pattern."),Object(i.b)("p",null,"Now, look at the following example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-haskell"},'-- with the dot operator\nd1 \n  $ every 2 (# speed 2) . fast 2\n  $ s "bd hh bd hh"\n\n-- without the dot operator\nd1 \n  $ every 2 (# speed 2) \n  $\xa0fast 2\n  $ s "bd hh bd hh"\n')),Object(i.b)("p",null,"We did the same thing using two different methods:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},'we "composed" a new function made of the output of ',Object(i.b)("inlineCode",{parentName:"li"},"fast 2")," fed to the ",Object(i.b)("inlineCode",{parentName:"li"},"every 2 (# speed 2)")," function."),Object(i.b)("li",{parentName:"ol"},"we passed the result of ",Object(i.b)("inlineCode",{parentName:"li"},'fast 2 $\xa0s "bd hh bd hh"')," to ",Object(i.b)("inlineCode",{parentName:"li"},"every 2 (# speed 2)"),".")),Object(i.b)("p",null,"Luckily for us, these two examples sound the same. But you might start to see that we haven't applied the same method to get to the same result. Actually, we used two different ",Object(i.b)("inlineCode",{parentName:"p"},"function composition")," operators."),Object(i.b)("p",null,"The dot (",Object(i.b)("inlineCode",{parentName:"p"},"."),') will take many of your functions and "compose" them together to make one single function that you can feed to another one as if it had always been a single function the whole time. Let\'s take a look at a more complex example that will do just that:'),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-haskell"},'d1 \n  $ superimpose ((# speed "2*12") . (# squiz (slow 2 $ range 1 16 $\xa0sine)) . (striate\n  "[4|2|3]") . (ply "[[1 1 2 4]|[1 1 2 2]]") . (# room "0 0.5") . (# sz "0.2 0.4"))\n  $\xa0fast 2\n  $ s "bd hh bd hh" # amp 0.4\n\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"superimpose")," expects a modified version of a pattern and our regular pattern. I fed only one function to describe the modified version, but I used the ",Object(i.b)("inlineCode",{parentName:"p"},".")," to chain together many functions that will now be counted as one. The isolated modified function looks like:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-haskell"},'((# speed "2*12") . (# squiz (slow 2 $ range 1 16 $\xa0sine)) . (striate\n  "[4|2|3]") . (ply "[[1 1 2 4]|[1 1 2 2]]") . (# room "0 0.5") . (# sz "0.2 0.4"))\n')),Object(i.b)("p",null,"Let's see the type of this function using ",Object(i.b)("inlineCode",{parentName:"p"},":t"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-haskell"},":: Pattern ControlMap -> Pattern ControlMap\n")),Object(i.b)("p",null,"Cool! As you can see, we are in fact dealing with a super simple object, made of many many tiny parts chained together using ",Object(i.b)("inlineCode",{parentName:"p"},"."),"."),Object(i.b)("h2",{id:"why-should-i-use-it"},"Why should I use it?"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},".")," is a very elegant operator to chain together functions at the speed of light. Using it, you might be able to compose more complex patterns easily."))}p.isMDXComponent=!0},208:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var o=n(0),a=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,b=u["".concat(r,".").concat(m)]||u[m]||d[m]||i;return n?a.a.createElement(b,l(l({ref:t},c),{},{components:n})):a.a.createElement(b,l({ref:t},c))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);