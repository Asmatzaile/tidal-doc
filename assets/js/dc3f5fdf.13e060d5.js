"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8020],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=c(t),m=i,h=u["".concat(s,".").concat(m)]||u[m]||p[m]||l;return t?a.createElement(h,o(o({ref:n},d),{},{components:t})):a.createElement(h,o({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,o=new Array(l);o[0]=m;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:i,o[1]=r;for(var c=2;c<l;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1148:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>c});var a=t(3117),i=(t(7294),t(3905));const l={title:"MIDI",id:"midi",permalink:"wiki/MIDI/",layout:"wiki"},o=void 0,r={unversionedId:"configuration/MIDIOSC/midi",id:"configuration/MIDIOSC/midi",title:"MIDI",description:"Tidal can send and receive MIDI messages. You can talk with external synthesizers and hardware and receive data from your controllers. All the mapping is done directly through the language in an intuitive way.",source:"@site/docs/configuration/MIDIOSC/MIDI.md",sourceDirName:"configuration/MIDIOSC",slug:"/configuration/MIDIOSC/midi",permalink:"/docs/configuration/MIDIOSC/midi",draft:!1,editUrl:"https://github.com/tidalcycles/tidal-doc/tree/main/docs/configuration/MIDIOSC/MIDI.md",tags:[],version:"current",lastUpdatedBy:"Pierre Krafft",lastUpdatedAt:1672231607,formattedLastUpdatedAt:"Dec 28, 2022",frontMatter:{title:"MIDI",id:"midi",permalink:"wiki/MIDI/",layout:"wiki"},sidebar:"docs",previous:{title:"Adding Synthesizers",permalink:"/docs/configuration/adding_synthesizers"},next:{title:"OSC",permalink:"/docs/configuration/MIDIOSC/osc"}},s={},c=[{value:"SuperDirt MIDI",id:"superdirt-midi",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Initialization",id:"initialization",level:3},{value:"Usage in Tidal",id:"usage-in-tidal",level:3},{value:"Note Patterns",id:"note-patterns",level:4},{value:"MIDI Channels",id:"midi-channels",level:4},{value:"CC Params",id:"cc-params",level:4},{value:"Tidal-Midi",id:"tidal-midi",level:2},{value:"Synchronising MIDI clock",id:"synchronising-midi-clock",level:3},{value:"Synchronising MIDI clock using the Link protocol",id:"synchronising-midi-clock-using-the-link-protocol",level:4},{value:"Ableton Live as the MIDI clock source",id:"ableton-live-as-the-midi-clock-source",level:5},{value:"SuperCollider as the MIDI clock source",id:"supercollider-as-the-midi-clock-source",level:5},{value:"Synchronising MIDI clock via Tidal",id:"synchronising-midi-clock-via-tidal",level:4},{value:"Controller Input",id:"controller-input",level:2},{value:"Setup",id:"setup",level:3},{value:"Usage",id:"usage",level:3},{value:"Renaming MIDI notes",id:"renaming-midi-notes",level:3},{value:"Alternative with Pure Data",id:"alternative-with-pure-data",level:3}],d={toc:c};function u(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Tidal can send and receive MIDI messages. You can talk with external synthesizers and hardware and receive data from your controllers. All the mapping is done directly through the language in an intuitive way."),(0,i.kt)("h2",{id:"superdirt-midi"},"SuperDirt MIDI"),(0,i.kt)("h3",{id:"prerequisites"},"Prerequisites"),(0,i.kt)("p",null,"The prerequisites require recent versions of ",(0,i.kt)("strong",{parentName:"p"},"Tidal")," and ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Upgrade to the latest Tidal (this post assumes version 0.9.10 or greater)"),(0,i.kt)("li",{parentName:"ul"},"Make sure you have the latest ",(0,i.kt)("strong",{parentName:"li"},"SuperDirt quark"),". Uninstalling and reinstalling the SuperDirt quark might be easiest. See ",(0,i.kt)("a",{parentName:"li",href:"github.com/supercollider-quarks/quarks"},"this page")," for details on how to update Quarks.")),(0,i.kt)("h3",{id:"initialization"},"Initialization"),(0,i.kt)("p",null,"To begin, you'll start in ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider"),". Start up ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt")," as you normally would. Then, in SuperCollider eval the following code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"MIDIClient.init;\n")),(0,i.kt)("p",null,"You should now see a list of the system MIDI devices in ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider"),"'s post window. The output will look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'MIDI Sources:\n    MIDIEndPoint("LoopBe Internal MIDI", "LoopBe Internal MIDI")\n    MIDIEndPoint("Focusrite USB MIDI", "Focusrite USB MIDI")\nMIDI Destinations:\n    MIDIEndPoint("Microsoft GS Wavetable Synth", "Microsoft GS Wavetable Synth")\n    MIDIEndPoint("LoopBe Internal MIDI", "LoopBe Internal MIDI")\n    MIDIEndPoint("Focusrite USB MIDI", "Focusrite USB MIDI")\n')),(0,i.kt)("p",null,"Take note that these MIDI devices have two parts to their names. You will need both parts in the next step, which is to actually connect to the MIDI device. Eval the following line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'~midiOut = MIDIOut.newByName("Focusrite USB MIDI", "Focusrite USB MIDI"); // substitute your own device here\n')),(0,i.kt)("p",null,"Above, we have stored a reference to the device in a variable named ",(0,i.kt)("inlineCode",{parentName:"p"},"~midiOut"),"."),(0,i.kt)("p",null,'Finally, define the name of the "synth" in Tidal you will use to control this device. Below, we will call it "midi". Eval the following line:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"~dirt.soundLibrary.addMIDI(\\midi, ~midiOut);\n")),(0,i.kt)("p",null,"Optionally, you can define a latency value on your device:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"~midiOut.latency = 0.45;\n")),(0,i.kt)("p",null,'That\'s it for initialization. You should now have a MIDI device connected in SuperDirt, running as a synth named "midi".'),(0,i.kt)("h3",{id:"usage-in-tidal"},"Usage in Tidal"),(0,i.kt)("h4",{id:"note-patterns"},"Note Patterns"),(0,i.kt)("p",null,"Now we can start writing some Tidal patterns to control the MIDI device. Let's send it a trivial note pattern:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d1 $ n "0 2 4 7" # s "midi"\n')),(0,i.kt)("p",null,'That should play a simple four-note pattern. Notice we\'re just using the synth name "midi" to send notes to the MIDI device.'),(0,i.kt)("p",null,"You can also use the note-name and octave notation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d1 $ n "c4 d4 e5 g3" # s "midi"\n')),(0,i.kt)("h4",{id:"midi-channels"},"MIDI Channels"),(0,i.kt)("p",null,"The default MIDI channel is 1. SuperDirt MIDI channels are indexed starting at zero, so MIDI channel 1 is midichan 0:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d1 $ note "0 2 4 7" # s "midi" # midichan 0\n')),(0,i.kt)("p",null,"If your synth is listening on a different channel, let's say, MIDI channel 5, you would use midichan 4:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d1 $ note "0 2 4 7" # s "midi" # midichan 4\n')),(0,i.kt)("p",null,"Notice that midichan accepts a pattern of numbers, so you can use a pattern to play on different MIDI channels:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d1 $ note "0 2 4 7" # s "midi" # midichan "0 4"\n')),(0,i.kt)("p",null,'The above pattern plays notes "0 2" on channel 1 and "4 7" on channel 5.'),(0,i.kt)("h4",{id:"cc-params"},"CC Params"),(0,i.kt)("p",null,"To send a CC param to your synth, the best way to do it in the new SuperDirt MIDI is with a different Tidal pattern. To create this pattern, you'll be using two new SuperDirt MIDI params:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ccn"),": the CC param number you want to control: ccn 30"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ccv"),": the value to send to the CC param, ranging from 0 to 127: ccv 64")),(0,i.kt)("p",null,"Here's a full example, sending a value of 64 to CC param 30:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d2 $ ccv 64 # ccn 30 # s "midi"\n')),(0,i.kt)("p",null,"You can of course also specify the MIDI channel with midichan:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d2 $ ccv 64 # ccn 30 # s "midi" # midichan 4\n')),(0,i.kt)("p",null,"You can specify patterns of CC values:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d2 $ ccv "20 40 60 80 100" # ccn 30 # s "midi"\n\nd2 $ ccn "30*4" # ccv (range 20 100 $ slow 30 sine) # s "midi"\n')),(0,i.kt)("p",null,"Note that the left-most pattern defines the rhythm in this case when using ",(0,i.kt)("inlineCode",{parentName:"p"},"#"),"."),(0,i.kt)("p",null,"If you have a specific feature on your device that listens on a specific CC number, you can give it a friendly name if you wish:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'let ringMod = 30\nd2 $ ccv "0 20 50 60" # ccn ringMod # s "midi"\n')),(0,i.kt)("p",null,"If you have many CC params you want to control at once, a stack works well:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'d2 $ density 8 $ stack [\n  ccn 30 # ccv (range 0 127 $ slow 30 sine),\n  ccn 31 # ccv "[0 70 30 110]/3",\n  ccn 32 # ccv 10\n  ] # s "midi"\n')),(0,i.kt)("h2",{id:"tidal-midi"},"Tidal-Midi"),(0,i.kt)("p",null,"The older ",(0,i.kt)("inlineCode",{parentName:"p"},"tidal-midi")," Haskell module is not currently working (although it might return). Use the other existing solutions."),(0,i.kt)("h3",{id:"synchronising-midi-clock"},"Synchronising MIDI clock"),(0,i.kt)("p",null,"It is often important to send MIDI clock events to synchronize tempo between devices.\nTidal can't sync its tempo to MIDI clock events that it receives, but it can act as a MIDI clock source.\nThe following sections show two alternatives for sending MIDI clock events that follow the tempo of Tidal."),(0,i.kt)("h4",{id:"synchronising-midi-clock-using-the-link-protocol"},"Synchronising MIDI clock using the Link protocol"),(0,i.kt)("p",null,"Since version 1.9, Tidal uses the Link protocol for scheduling events.\nLink is a technology that synchronizes musical beat, tempo, and phase across multiple applications. It was originally developed by a company called Ableton, but is open source and now implemented in a wide range of music software.\nWe can use Link to synchronize Tidal with a separate program that will act as the MIDI clock source.\nThis is the preferred method for sending MIDI clock events as it is easy, performant, stable, and has fewer quirks than ",(0,i.kt)("a",{parentName:"p",href:"#synchronising-midi-clock-via-tidal"},"Synchronising MIDI clock via Tidal"),"."),(0,i.kt)("h5",{id:"ableton-live-as-the-midi-clock-source"},"Ableton Live as the MIDI clock source"),(0,i.kt)("p",null,"Ableton Live can synchronize with Tidal over Link and simultaneously send MIDI clock messages.\nTo achieve this, follow both instructions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Turn on Link sync in Ableton Live. See ",(0,i.kt)("a",{parentName:"li",href:"https://www.ableton.com/en/manual/synchronizing-with-link-tempo-follower-and-midi/#32-1-synchronizing-via-link"},"Synchronizing via Link"),"."),(0,i.kt)("li",{parentName:"ul"},"Turn the MIDI device on as a sync destination in Live\u2019s Link/Tempo/MIDI Preferences. See ",(0,i.kt)("a",{parentName:"li",href:"https://www.ableton.com/en/manual/synchronizing-with-link-tempo-follower-and-midi/#32-3-1-synchronizing-external-midi-devices-to-live"},"Synchronizing External MIDI Devices to Live"),".")),(0,i.kt)("h5",{id:"supercollider-as-the-midi-clock-source"},"SuperCollider as the MIDI clock source"),(0,i.kt)("p",null,"We can use Link to synchronize Tidal with SuperCollider and set up SuperCollider to send MIDI clock events. This method was inspired by ",(0,i.kt)("a",{parentName:"p",href:"https://scsynth.org/t/midi-clock-out-separate-process-for-better-stability/5089"},"jamshark70's thread"),". This requires extending SuperCollider with a new class ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkToMidiClock"),"."),(0,i.kt)("p",null,"First decide if the SuperCollider class should be available only to your user account or to all users on the machine. Then find the corresponding extensions directory by running one of these lines in SuperCollider:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"Platform.userExtensionDir;   // Extensions available only to your user account\nPlatform.systemExtensionDir; // Extensions available to all users on the machine\n")),(0,i.kt)("p",null,"Create a file ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkToMidiClock.sc")," in the selected extensions directory and save it with this content:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},'LinkToMidiClock {\n    var <midiOut, <linkClock, routine, <isPlaying = false, d;\n\n    *new { arg midiOut, linkClock;\n        ^super.newCopyArgs(midiOut, linkClock)\n    }\n\n    start {\n        if(isPlaying,{\n            "Can\'t start. LinkToMidiClock is already playing".inform;\n        },{\n            isPlaying = true;\n            d = 1/24;\n            routine = Routine {\n                midiOut.start;\n                loop {\n                    23.do { |i|\n                        midiOut.midiClock;\n                        d.wait;\n                    };\n                    midiOut.midiClock;\n                    (thisThread.clock.beats.ceil - thisThread.beats).wait;\n                }\n            }.play(linkClock, [linkClock.quantum, 0]);\n        });\n    }\n\n    stop {\n        if(isPlaying,{\n            isPlaying = false;\n            midiOut.stop;\n            routine.stop;\n        },{\n            "Can\'t stop. LinkToMidiClock is not playing".inform;\n        })\n    }\n}\n')),(0,i.kt)("p",null,"Reboot SuperCollider or use ",(0,i.kt)("inlineCode",{parentName:"p"},"Language > Recompile Class Library"),"."),(0,i.kt)("p",null,"We are now ready to follow the ",(0,i.kt)("a",{parentName:"p",href:"#Initialization"},"initialization")," guide. We will use the MIDI device variable named ",(0,i.kt)("inlineCode",{parentName:"p"},"~midiOut")," from the initialization in the examples below."),(0,i.kt)("p",null,"After the MIDI device is initialized, create a ",(0,i.kt)("a",{parentName:"p",href:"https://doc.sccode.org/Classes/LinkClock.html"},"LinkClock")," in SuperCollider."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~lc = LinkClock.new.latency_(Server.default.latency);\n")),(0,i.kt)("p",null,"You can check that Tidal and SuperCollider have connected over Link by checking the number of Link peers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"~lc.numPeers; '0 means no connection, 1 means connection\n")),(0,i.kt)("p",null,"Then, create a ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkToMidiClock")," that is connected to the MIDI device ",(0,i.kt)("inlineCode",{parentName:"p"},"~midiOut")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkClock")," ",(0,i.kt)("inlineCode",{parentName:"p"},"~lc"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~ltmc = LinkToMidiClock(~midiOut, ~lc);\n")),(0,i.kt)("p",null,"MIDI clock events will be sent continously after we tell it to start, until we tell it to stop."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~ltmc.start;\n~ltmc.stop;\n")),(0,i.kt)("p",null,"Note: If SuperCollider and Tidal don't connect over Link, try starting Tidal before the LinkClock is created, but after SuperDirt is started. Alternatively, try creating the LinkClock before starting Tidal. This has anecdotally worked in some cases. Please report your findings in ",(0,i.kt)("a",{parentName:"p",href:"https://club.tidalcycles.org/t/tidalcycles-version-1-9-0/4292"},"the TidalCycles version 1.9.0 nnouncement thread"),"."),(0,i.kt)("p",null,"For more details on Tidal's integration with Link, see ",(0,i.kt)("a",{parentName:"p",href:"../multiuser-tidal#link-protocol-synchronization"},"Multi-User Tidal"),"."),(0,i.kt)("h4",{id:"synchronising-midi-clock-via-tidal"},"Synchronising MIDI clock via Tidal"),(0,i.kt)("p",null,"We can alternatively use Tidal and ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt MIDI")," for sending MIDI clock events. The advantage is that it also works in older versions of Tidal, but the method is somewhat more complicated."),(0,i.kt)("p",null,"Set up ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt MIDI")," by following the ",(0,i.kt)("a",{parentName:"p",href:"#Initialization"},"initialization")," guide."),(0,i.kt)("p",null,"When that is done, you can start sending MIDI clock messages, 48 per cycle, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'p "midiclock" $ midicmd "midiClock*48" # s "midi"\n')),(0,i.kt)("p",null,"Your MIDI device should adjust its BPM to Tidal's cps. It's then a good idea to send a ",(0,i.kt)("inlineCode",{parentName:"p"},"stop")," message like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'once $ midicmd "stop" # s "midi"\n')),(0,i.kt)("p",null,"and then finally a start message to start the MIDI clock at the right time. The following sends a start message every fourth cycle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'p "midictl" $ midicmd "start/4" # s "midi"\n\n')),(0,i.kt)("p",null,"Once everything's started and in sync, it's probably best to stop sending the start messages to avoid glitching:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'p "midictl" $ silence\n')),(0,i.kt)("p",null,"However now if you do hush, the ",(0,i.kt)("inlineCode",{parentName:"p"},"midiclock")," will stop as well as all the other patterns. To avoid this, you can overwrite the hush function with a version that silences particular patterns:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"let hush = mapM_ ($ silence) [d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16]\n")),(0,i.kt)("p",null,"You will probably find that the downbeats for SuperDirt and your MIDI devices don't align. As a starting point, set MIDI latency in supercollider to 0:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-supercollider"},"~midiOut.latency = 0;\n")),(0,i.kt)("p",null,"Make sure any offset on the MIDI side is also set to 0, then gradually adjust one of them until they align. If they stay in alignment when you change the cps, all is good!"),(0,i.kt)("h2",{id:"controller-input"},"Controller Input"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Tidal")," 1.0.0 now has support for external input, using the OSC protocol. Here's a quick guide to getting it going, including using a simple 'bridge' for getting MIDI input working."),(0,i.kt)("h3",{id:"setup"},"Setup"),(0,i.kt)("p",null,"To use MIDI, you don't have to worry too much about mapping OSC. However, you do have to run something to convert MIDI into OSC (",(0,i.kt)("strong",{parentName:"p"},"Tidal")," is listening for OSC messages). Here's how to do that using SuperCollider. First, with ",(0,i.kt)("strong",{parentName:"p"},"Tidal")," and ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt")," already running, run the below code block in ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Evaluate the block below to start the mapping MIDI -> OSC.\n(\nvar on, off, cc;\nvar osc;\n\nosc = NetAddr.new("127.0.0.1", 6010);\n\nMIDIClient.init;\nMIDIIn.connectAll;\n\non = MIDIFunc.noteOn({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, val/127);\n});\n\noff = MIDIFunc.noteOff({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, 0);\n});\n\ncc = MIDIFunc.cc({ |val, num, chan, src|\n    osc.sendMsg("/ctrl", num.asString, val/127);\n});\n\nif (~stopMidiToOsc != nil, {\n    ~stopMidiToOsc.value;\n});\n\n~stopMidiToOsc = {\n    on.free;\n    off.free;\n    cc.free;\n};\n)\n\n// Evaluate the line below to stop it.\n~stopMidiToOsc.value;\n')),(0,i.kt)("h3",{id:"usage"},"Usage"),(0,i.kt)("p",null,"You should then be able to run a pattern such as the following, that uses ",(0,i.kt)("inlineCode",{parentName:"p"},"CC value 12"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "bd" # speed (cF 1 "12")\n')),(0,i.kt)("p",null,"If you want to use MIDI in a pattern forming statement, you may find it helpful to ",(0,i.kt)("inlineCode",{parentName:"p"},"segment")," the input first, as the raw pattern coming from your MIDI device will be at very high resolution. This example takes only one value per cycle & remaps the value with the ",(0,i.kt)("inlineCode",{parentName:"p"},"range")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ sound "amencutup" + n (run (segment 1 $ range 1 16 $ cN 0 "32" ))\n')),(0,i.kt)("h3",{id:"renaming-midi-notes"},"Renaming MIDI notes"),(0,i.kt)("p",null,"In case you have a MIDI drum machine, where the bassdrum is on MIDI note 231 and you don't want to write ",(0,i.kt)("inlineCode",{parentName:"p"},"231")," every time, you could either do this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'s2n :: String -> Note\ns2n "BD" = 231\ns2n _ = 0\n\nd1 $ n (s2n <$> "BD*4") # sound "tr8" # midichan 9\n')),(0,i.kt)("p",null,"Another approach is using ",(0,i.kt)("inlineCode",{parentName:"p"},"inhabit"),", you pass it a list of names and patterns, like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("sd", "232")] pat)\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'d1 $ drum "bd sd" # midichan 9\n')),(0,i.kt)("p",null,"You could also hide the midi channel in there so you don't have to type it each time"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("sd", "232")] pat) # midichan 9\n\nd1 $ drum "bd sd"\nd2 $ drum "bd*3 sd*2"\n')),(0,i.kt)("p",null,"Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"232")," bit is a pattern, so you could have one name trigger more than one event e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},'let drum pat = sound (inhabit [("bd", "231"), ("rush", "232*8"), ("sd", "232")] pat) # midichan 9\n\nd1 $ drum "bd sd rush"\n')),(0,i.kt)("h3",{id:"alternative-with-pure-data"},"Alternative with Pure Data"),(0,i.kt)("p",null,"The above ",(0,i.kt)("strong",{parentName:"p"},"SuperCollider")," instructions are most convenient if you're using ",(0,i.kt)("strong",{parentName:"p"},"SuperDirt"),", but as an alternative you can use ",(0,i.kt)("strong",{parentName:"p"},"Pure Data")," to convert midi to ",(0,i.kt)("strong",{parentName:"p"},"OSC"),". You can get puredata from ",(0,i.kt)("a",{parentName:"p",href:"https://puredata.info/"},"here")," (the ",(0,i.kt)("inlineCode",{parentName:"p"},"vanilla")," version is recommended). Then, download ",(0,i.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/tidalcycles/Tidal/main/pd/midi-osc-bridge.pd"},"this file"),". Then if you start ",(0,i.kt)("strong",{parentName:"p"},"Tidal"),", open that file in ",(0,i.kt)("strong",{parentName:"p"},"Pure Data"),", and configure your ",(0,i.kt)("strong",{parentName:"p"},"MIDI")," device in ",(0,i.kt)("strong",{parentName:"p"},"Pure Data"),", things should start working."))}u.isMDXComponent=!0}}]);